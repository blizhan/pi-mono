# Session & Compaction Design Deep Dive

## 1. 为什么必须做会话治理

Agent 应用进入真实生产后，失败往往不是模型能力不足，而是“上下文治理失败”：

- 消息过长导致成本高、延迟高、截断频繁。
- 工具回传冗余数据导致上下文污染。
- 长链路任务中断后无法恢复。

因此，Session 与 Compaction 是核心能力，不是优化项。

---

## 2. 会话模型建议

建议会话至少包含：

- `sessionId`
- `messages`
- `metadata`（标题、时间、标签、模型策略）
- `branches`（可选）
- `compactionHistory`

分支化（branching）价值：

- 在高风险操作前开分支，支持回滚。
- 并行探索不同工具路径。
- 为评估系统保留可比实验轨迹。

---

## 3. Compaction 触发策略

推荐组合触发：

1. **Token 阈值触发**：接近模型上下文上限时。
2. **轮次触发**：固定 N 轮进行轻量压缩。
3. **类型触发**：工具结果超大（日志、JSON、HTML）时。
4. **成本触发**：单位任务成本超预算时。

---

## 4. Compaction 分层策略

建议采用三层压缩：

1. **消息级压缩**：
   - 删除无价值中间输出
   - 工具长结果转摘要 + 引用
2. **阶段级摘要**：
   - 把一段任务过程聚合成目标、操作、结果、未决事项
3. **全局状态摘要**：
   - 长会话保留“全局事实表”与“当前行动计划”

关键原则：

- 保事实，不保噪声。
- 保决策理由，不保冗余推理细节。
- 保可恢复锚点（文件路径、命令、工具结果引用）。

---

## 5. 工具输出治理

工具输出是上下文膨胀最大来源，建议：

- 默认截断 + 摘要（保前 N 行 + 后 N 行）。
- 二进制/大文本只存引用（artifact id），不直接进上下文。
- 对结构化输出（JSON）做 schema-aware 摘要。

---

## 6. 可恢复性设计

会话系统要支持“崩溃后继续”：

1. 每轮写入 WAL（或 append-only log）。
2. 工具调用状态显式记录（pending/running/success/failed）。
3. 恢复时可判定哪些调用可重放、哪些要跳过。

---

## 7. 评估指标（必须量化）

建议持续观测：

- 平均每轮 token
- compaction 后 token 降幅
- 任务完成率
- 恢复成功率
- 单任务成本

没有指标的 compaction 只能靠体感，难以长期优化。

---

## 8. 最小落地清单

1. 先做 append-only session log。
2. 实现 token 阈值触发压缩。
3. 工具结果默认摘要化。
4. 增加 compaction 前后统计。
5. 增加人工“强制压缩”开关用于调试。

